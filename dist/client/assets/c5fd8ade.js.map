{"version":3,"file":"c5fd8ade.js","sources":["../../../node_modules/@shopify/hydrogen/dist/esnext/utilities/hash.js","../../../node_modules/@shopify/hydrogen/dist/esnext/utilities/suspense.js","../../../node_modules/@shopify/hydrogen/dist/esnext/utilities/parse.js","../../../node_modules/@shopify/hydrogen/dist/esnext/foundation/fetchSync/client/fetchSync.js"],"sourcesContent":["import { STOREFRONT_API_BUYER_IP_HEADER } from '../constants';\nexport function hashKey(queryKey) {\n    const rawKeys = Array.isArray(queryKey) ? queryKey : [queryKey];\n    let hash = '';\n    // Keys from useShopQuery are in the following shape:\n    // ['prefix', 'api-endpoint', {body:'query',headers:{}}]\n    // Since the API endpoint already contains the shop domain and api version,\n    // we can ignore the headers and only use the `body` from the payload.\n    for (const key of rawKeys) {\n        if (key != null) {\n            if (typeof key === 'object') {\n                // Queries from useQuery might not have a `body`. In that case,\n                // fallback to a safer (but slower) stringify.\n                if (!!key.body && typeof key.body === 'string') {\n                    hash += key.body;\n                    if (!!key.headers && key.headers[STOREFRONT_API_BUYER_IP_HEADER]) {\n                        hash += key.headers[STOREFRONT_API_BUYER_IP_HEADER];\n                    }\n                }\n                else {\n                    hash += JSON.stringify(key);\n                }\n            }\n            else {\n                hash += key;\n            }\n        }\n    }\n    return hash;\n}\n","import { hashKey } from './hash';\n/**\n * Wrap the fetch promise in a way that React Suspense understands.\n * Essentially, keep throwing something until you have legit data.\n */\nexport function wrapPromise(promise) {\n    let status = 'pending';\n    let response;\n    const suspender = promise.then((res) => {\n        status = 'success';\n        response = res;\n    }, (err) => {\n        status = 'error';\n        response = err;\n    });\n    const read = () => {\n        switch (status) {\n            case 'pending':\n                throw suspender;\n            case 'error':\n                throw response;\n            default:\n                return response;\n        }\n    };\n    return { read };\n}\nconst browserCache = {};\n/**\n * Perform an async function in a synchronous way for Suspense support.\n * To be used only in the client.\n * Inspired by https://github.com/pmndrs/suspend-react\n */\nfunction query(key, fn, preload = false) {\n    const stringKey = hashKey(key);\n    if (browserCache[stringKey]) {\n        const entry = browserCache[stringKey];\n        if (preload)\n            return undefined;\n        if (entry.error)\n            throw entry.error;\n        if (entry.response)\n            return entry.response;\n        if (!preload)\n            throw entry.promise;\n    }\n    const entry = {\n        promise: fn()\n            .then((response) => (entry.response = response))\n            .catch((error) => (entry.error = error)),\n    };\n    browserCache[stringKey] = entry;\n    if (!preload)\n        throw entry.promise;\n    return undefined;\n}\nexport const suspendFunction = (key, fn) => query(key, fn);\nexport const preloadFunction = (key, fn) => query(key, fn, true);\n","export function parseJSON(json) {\n    if (String(json).includes('__proto__'))\n        return JSON.parse(json, noproto);\n    return JSON.parse(json);\n}\nfunction noproto(k, v) {\n    if (k !== '__proto__')\n        return v;\n}\n","import { parseJSON } from '../../../utilities/parse';\nimport { suspendFunction, preloadFunction } from '../../../utilities/suspense';\n/**\n * Fetch a URL for use in a client component Suspense boundary.\n */\nexport function fetchSync(url, options) {\n    const [text, response] = suspendFunction([url, options], async () => {\n        const response = await globalThis.fetch(url, options);\n        const text = await response.text();\n        return [text, response];\n    });\n    return {\n        response,\n        json: () => parseJSON(text),\n        text: () => text,\n    };\n}\n/**\n * Preload a URL for use in  a client component Suspense boundary.\n * Useful for placing higher in the tree to avoid waterfalls.\n */\nexport function preload(url, options) {\n    preloadFunction([url, options], async () => {\n        const response = await globalThis.fetch(url, options);\n        const text = await response.text();\n        return [text, response];\n    });\n}\n"],"names":[],"mappings":"wCACO,WAAiB,EAAU,CAC9B,KAAM,GAAU,MAAM,QAAQ,CAAQ,EAAI,EAAW,CAAC,CAAQ,EAC9D,GAAI,GAAO,GAKX,SAAW,KAAO,GACd,AAAI,GAAO,MACP,CAAI,MAAO,IAAQ,SAGf,AAAI,CAAC,CAAC,EAAI,MAAQ,MAAO,GAAI,MAAS,SAClC,IAAQ,EAAI,KACR,CAAC,CAAC,EAAI,SAAW,EAAI,QAAQ,IAC7B,IAAQ,EAAI,QAAQ,KAIxB,GAAQ,KAAK,UAAU,CAAG,EAI9B,GAAQ,GAIpB,MAAO,EACX,CCFA,KAAM,GAAe,CAAA,EAMrB,WAAe,EAAK,EAAI,EAAU,GAAO,CACrC,KAAM,GAAY,EAAQ,CAAG,EAC7B,GAAI,EAAa,GAAY,CACzB,KAAM,GAAQ,EAAa,GAC3B,GAAI,EACA,OACJ,GAAI,EAAM,MACN,KAAM,GAAM,MAChB,GAAI,EAAM,SACN,MAAO,GAAM,SACjB,GAAI,CAAC,EACD,KAAM,GAAM,OACnB,CACD,KAAM,GAAQ,CACV,QAAS,EAAI,EACR,KAAK,AAAC,GAAc,EAAM,SAAW,CAAS,EAC9C,MAAM,AAAC,GAAW,EAAM,MAAQ,CAAM,CACnD,EAEI,GADA,EAAa,GAAa,EACtB,CAAC,EACD,KAAM,GAAM,OAEpB,CACO,KAAM,GAAkB,CAAC,EAAK,IAAO,EAAM,EAAK,CAAE,ECxDlD,WAAmB,EAAM,CAC5B,MAAI,QAAO,CAAI,EAAE,SAAS,WAAW,EAC1B,KAAK,MAAM,EAAM,CAAO,EAC5B,KAAK,MAAM,CAAI,CAC1B,CACA,WAAiB,EAAG,EAAG,CACnB,GAAI,IAAM,YACN,MAAO,EACf,CCHO,WAAmB,EAAK,EAAS,CACpC,KAAM,CAAC,EAAM,GAAY,EAAgB,CAAC,EAAK,CAAO,EAAG,SAAY,CACjE,KAAM,GAAW,KAAM,YAAW,MAAM,EAAK,CAAO,EAEpD,MAAO,CADM,KAAM,GAAS,OACd,CAAQ,CAC9B,CAAK,EACD,MAAO,CACH,WACA,KAAM,IAAM,EAAU,CAAI,EAC1B,KAAM,IAAM,CACpB,CACA"}
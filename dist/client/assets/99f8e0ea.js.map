{"version":3,"file":"99f8e0ea.js","sources":["../../../node_modules/@shopify/hydrogen/dist/esnext/hooks/useProductOptions/helpers.js","../../../node_modules/@shopify/hydrogen/dist/esnext/components/ProductOptionsProvider/ProductOptionsProvider.client.js"],"sourcesContent":["export function getAllOptionValues(variants, option) {\n    return Array.from(new Set(variants.map((variant) => variant.selectedOptions.find((selection) => selection.name == option)\n        .value)));\n}\nexport function getSelectedVariant(variants, choices) {\n    /**\n     * Ensure the user has selected all the required options, not just some.\n     */\n    if (!variants.length ||\n        variants?.[0]?.selectedOptions?.length !== Object.keys(choices).length) {\n        return;\n    }\n    return variants?.find((variant) => {\n        return Object.entries(choices).every(([name, value]) => {\n            return variant?.selectedOptions?.some((option) => option?.name === name && option?.value === value);\n        });\n    });\n}\nexport function getOptions(variants) {\n    const map = variants.reduce((memo, variant) => {\n        if (!variant.selectedOptions) {\n            throw new Error(`getOptions requires 'variant.selectedOptions`);\n        }\n        variant?.selectedOptions?.forEach((opt) => {\n            memo[opt?.name ?? ''] = memo[opt?.name ?? ''] || new Set();\n            memo[opt?.name ?? ''].add(opt?.value ?? '');\n        });\n        return memo;\n    }, {});\n    return Object.keys(map).map((option) => {\n        return {\n            name: option,\n            values: Array.from(map[option]),\n        };\n    });\n}\n","import React, { useMemo, useState, useEffect, useCallback } from 'react';\nimport { ProductOptionsContext } from './context';\nimport { getSelectedVariant, getOptions, } from '../../hooks/useProductOptions/helpers';\nimport { flattenConnection } from '../../utilities/flattenConnection';\nexport function ProductOptionsProvider({ children, data: product, initialVariantId: explicitVariantId, }) {\n    // The flattened variants\n    const variants = useMemo(() => flattenConnection(product.variants ?? {}), [product.variants]);\n    if (!isProductVariantArray(variants)) {\n        throw new Error(`<ProductOptionsProvider/> requires 'product.variants.nodes' or 'product.variants.edges'`);\n    }\n    // All the options available for a product, based on all the variants\n    const options = useMemo(() => getOptions(variants), [variants]);\n    /**\n     * Track the selectedVariant within the provider.\n     */\n    const [selectedVariant, setSelectedVariant] = useState(() => getVariantBasedOnIdProp(explicitVariantId, variants));\n    /**\n     * Track the selectedOptions within the provider. If a `initialVariantId`\n     * is passed, use that to select initial options.\n     */\n    const [selectedOptions, setSelectedOptions] = useState(() => getSelectedOptions(selectedVariant));\n    /**\n     * When the initialVariantId changes, we need to make sure we\n     * update the selected variant and selected options. If not,\n     * then the selected variant and options will reference incorrect\n     * values.\n     */\n    useEffect(() => {\n        const newSelectedVariant = getVariantBasedOnIdProp(explicitVariantId, variants);\n        setSelectedVariant(newSelectedVariant);\n        setSelectedOptions(getSelectedOptions(newSelectedVariant));\n    }, [explicitVariantId, variants]);\n    /**\n     * Allow the developer to select an option.\n     */\n    const setSelectedOption = useCallback((name, value) => {\n        setSelectedOptions((selectedOptions) => {\n            const opts = { ...selectedOptions, [name]: value };\n            setSelectedVariant(getSelectedVariant(variants, opts));\n            return opts;\n        });\n    }, [setSelectedOptions, variants]);\n    const isOptionInStock = useCallback((option, value) => {\n        const proposedVariant = getSelectedVariant(variants, {\n            ...selectedOptions,\n            ...{ [option]: value },\n        });\n        return proposedVariant?.availableForSale ?? true;\n    }, [selectedOptions, variants]);\n    const sellingPlanGroups = useMemo(() => flattenConnection(product.sellingPlanGroups ?? {}).map((sellingPlanGroup) => ({\n        ...sellingPlanGroup,\n        sellingPlans: flattenConnection(sellingPlanGroup?.sellingPlans ?? {}),\n    })), [product.sellingPlanGroups]);\n    /**\n     * Track the selectedSellingPlan within the hook. If `initialSellingPlanId`\n     * is passed, use that as an initial value. Look it up from the `selectedVariant`, since\n     * that is also a requirement.\n     */\n    const [selectedSellingPlan, setSelectedSellingPlan] = useState(undefined);\n    const selectedSellingPlanAllocation = useMemo(() => {\n        if (!selectedVariant || !selectedSellingPlan) {\n            return;\n        }\n        if (!selectedVariant.sellingPlanAllocations?.nodes &&\n            !selectedVariant.sellingPlanAllocations?.edges) {\n            throw new Error(`<ProductOptionsProvider/>: You must include 'sellingPlanAllocations.nodes' or 'sellingPlanAllocations.edges' in your variants in order to calculate selectedSellingPlanAllocation`);\n        }\n        return flattenConnection(selectedVariant.sellingPlanAllocations).find((allocation) => allocation?.sellingPlan?.id === selectedSellingPlan.id);\n    }, [selectedVariant, selectedSellingPlan]);\n    const value = useMemo(() => ({\n        variants,\n        variantsConnection: product.variants,\n        options,\n        selectedVariant,\n        setSelectedVariant,\n        selectedOptions,\n        setSelectedOption,\n        setSelectedOptions,\n        isOptionInStock,\n        selectedSellingPlan,\n        setSelectedSellingPlan,\n        selectedSellingPlanAllocation,\n        sellingPlanGroups,\n        sellingPlanGroupsConnection: product.sellingPlanGroups,\n    }), [\n        isOptionInStock,\n        options,\n        product.sellingPlanGroups,\n        product.variants,\n        selectedOptions,\n        selectedSellingPlan,\n        selectedSellingPlanAllocation,\n        selectedVariant,\n        sellingPlanGroups,\n        setSelectedOption,\n        variants,\n    ]);\n    return (React.createElement(ProductOptionsContext.Provider, { value: value }, children));\n}\nfunction getVariantBasedOnIdProp(explicitVariantId, variants) {\n    // get the initial variant based on the logic outlined in the comments for 'initialVariantId' above\n    // * 1. If `initialVariantId` is provided, then it's used even if it's out of stock.\n    if (explicitVariantId) {\n        const foundVariant = variants.find((variant) => variant?.id === explicitVariantId);\n        if (!foundVariant) {\n            console.warn(`<ProductOptionsProvider/> received a 'initialVariantId' prop, but could not actually find a variant with that ID`);\n        }\n        return foundVariant;\n    }\n    // * 2. If `initialVariantId` is provided but is `null`, then no variant is used.\n    if (explicitVariantId === null) {\n        return null;\n    }\n    // * 3. If nothing is passed to `initialVariantId` then the first available / in-stock variant is used.\n    // * 4. If nothing is passed to `initialVariantId` and no variants are in stock, then the first variant is used.\n    if (explicitVariantId === undefined) {\n        return variants.find((variant) => variant?.availableForSale) || variants[0];\n    }\n}\nfunction getSelectedOptions(selectedVariant) {\n    return selectedVariant?.selectedOptions\n        ? selectedVariant.selectedOptions.reduce((memo, optionSet) => {\n            memo[optionSet?.name ?? ''] = optionSet?.value ?? '';\n            return memo;\n        }, {})\n        : {};\n}\nfunction isProductVariantArray(maybeVariantArray) {\n    if (!maybeVariantArray || !Array.isArray(maybeVariantArray)) {\n        return false;\n    }\n    return true;\n}\n"],"names":["children","data","product","initialVariantId","explicitVariantId","variants","useMemo","flattenConnection","isProductVariantArray","Error","options","getOptions","selectedVariant","setSelectedVariant","useState","getVariantBasedOnIdProp","selectedOptions","setSelectedOptions","getSelectedOptions","useEffect","newSelectedVariant","setSelectedOption","useCallback","name","value","opts","getSelectedVariant","isOptionInStock","option","proposedVariant","availableForSale","sellingPlanGroups","map","sellingPlanGroup","sellingPlans","selectedSellingPlan","setSelectedSellingPlan","undefined","selectedSellingPlanAllocation","sellingPlanAllocations","nodes","edges","find","allocation","sellingPlan","id","variantsConnection","sellingPlanGroupsConnection","_jsx","foundVariant","variant","console","warn","reduce","memo","optionSet","maybeVariantArray","Array","isArray"],"mappings":"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"}